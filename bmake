#!/usr/bin/ruby
# Copyright (C) 2010, James Webber.
# Distributed under a 3-clause BSD license..  See COPYING.
#
# Wraps CMake's ctest with a more friendly UI and recognises my standard project
# structure.  See $0 --help

require 'optparse'
require 'pathname'
require 'fcntl'
require 'ostruct'

module CtestWrapper
  ROOT_SRC_DIR = Pathname.new('/home/bunker/src')
  ROOT_BIN_DIR = Pathname.new('/home/bunker/var/build')

  def Object.attr_bool_reader(*names)
    names.each {|name|
      module_eval "def #{name}?; @#{name}; end"
    }
  end

  class Settings
    # Base ~/var/bin ~/src dir.
    attr_reader :bin_dir, :src_dir
    # Directory under the main dirs, e.g. bin_dir + ./test/blah
    attr_reader :bin_subdir, :src_subdir
    # Either :bindir, or :bin_subdir, depending on settings.
    attr_reader :test_dir
    # Which tests to run.
    attr_reader :test_names, :test_regexes
    # Tests to run if they are valid (iow it's not an error if they don't
    # exist).
    attr_reader :maybe_test_names
    # -V in ctest.
    attr_bool_reader :verbose
    # Whether to run make.
    attr_bool_reader :make
    # [] for use nothing.
    attr_reader :make_names

    def initialize(args)
      @args = args
      @parser = make_parser
      @test_names = []
      @test_regexes = []
      @verbose = false
      @use_subdir = false
      @configuration = 'unix'
      @make = true
      @make_names = []
      @maybe_test_names = []
    end

    # Parses the arguments and maybe exits.
    def parse!
      begin
        @maybe_test_names = @parser.parse(@args)
      rescue OptionParser::ParseError => e
        STDERR.puts "bmake: #{e}"
        Kernel.exit 1
      end

      @make_names += @maybe_test_names

      if @make == false
        if ! @make_names.empty?
          STDERR.puts "bmake: make has been disabled but make targets have been given"
          Kernel.exit 1
        elsif @test_names.empty? && @test_regexes.empty?
          STDERR.puts "bmake: make has been disabled and no test names have been given"
          Kernel.exit 1
        end
      elsif @test_names.empty? && @make_names.empty?
        @name_names = ['all']
      end

      find_directories

      self
    end

    private

    def find_directories
      here = Pathname.new(Dir.pwd).realpath
      src_bits = split_path(ROOT_SRC_DIR)
      bin_bits = split_path(ROOT_BIN_DIR)
      here_bits = split_path(here)

      @src_dir = nil
      @bin_dir = nil

      # Check prefix is the same.
      if here_bits[0..(src_bits.length-1)] == src_bits
        project_name = here_bits[src_bits.length]
        subdir_bits = here_bits[(src_bits.length+1)..here_bits.length]
      elsif here_bits[0..(bin_bits.length-1)] == bin_bits
        project_name = here_bits[bin_bits.length]
        subdir_bits = here_bits[(bin_bits.length+1)..here_bits.length]
      else
        STDERR.puts "bmake: this script must be run in a source or binary dir."
        Kernel.exit(1)
      end

      project_root_src_dir = ROOT_SRC_DIR + project_name
      project_root_bin_dir = ROOT_BIN_DIR + project_name

      if ! project_root_src_dir.directory?
        fail "wtf"
      end

      if ! project_root_bin_dir.directory?
        STDERR.puts "bmake: this project does not appear to have a binary directory"
        Kernel.exit 1
      end

      project_root_bin_dir += "./#{@configuration}"
      if ! project_root_bin_dir.exist?
        STDERR.puts "bmake: configuration directory '#{@configuration}' does not exist"
        Kernel.exit 1
      end

      @src_dir = project_root_src_dir
      @bin_dir = project_root_bin_dir

      @src_subdir = @src_dir + File.join(subdir_bits)
      @bin_subdir = @bin_dir + File.join(subdir_bits)

      @test_dir = @use_subdir ? @bin_subdir : @bin_dir
    end

    def split_path(path)
      bits = []
      path.each_filename {|f| bits << f }
      bits
    end

    def make_parser
      op = OptionParser.new
      op.banner += " [targets]"
      op.banner += "\nBuilds and tests projects using the standard bunker project structure."
      op.banner += "\nTargets specified without arguments will be built with make and tested"
      op.banner += "\nonly if they are valid as test names."
      op.banner += "\n\n"

      op.separator "General:"
      op.on('-h', '--help', "Print these options and exit.") {
        puts op
        puts
        puts "bmake Copyright (C) James Webber, 2010."
        Kernel.exit 1
      }
      op.on('-s', '--subdir', "Use a binary dir which mirrors the path in the srcdir when running tests.") {
        listfile = Pathname.getwd + "./CMakeLists.txt"
        if ! listfile.exist?
          STDERR.puts "bmake: --subdir cannot be used when there is no CMakeLists.txt in the pwd."
          Kernel.exit 1
        end
        @use_subdir = true
      }
      op.on('-c', '--config=CONFIG', "Configuration dir.  Default is 'unix'.") {|name|
        @configuration = name
      }
      op.on('-v', '--verbose', "Always print outputs of tests.") { @verbose = true }

      op.separator "\nMaking:"
      op.on('-M', '--no-make', "Don't call make.") {
        @make = false
      }
      op.on('-m', '--make=NAME', "Run this target when using make.  Can be called multiple times.") {|val|
        @make_names << val
      }

      op.separator "\nTesting:"
      op.on('-t', '--test=NAME', "Name of test to run.  Can be given multiple times.") {|name|
        @test_names << name
      }
      op.on('-r', '--regex=EXPR', "A CMake regex to run tests matching.  Can be given multiple times.") {|val|
        @test_regexes << val
      }
      op.on('-T', '--test-target=NAME', "Same as giving -t NAME -m NAME.") {|name|
        @test_names << name
        @make_names << name
      }

      op
    end
  end

  class ForkExecError < RuntimeError
  end

  # Regarding making forks can running programs.
  module Fork
    # Fork a program.  Returns the [stdout, stderr, status] object.  Does not
    # print anything.
    def self.capture_command(*command_line)
      Fork.run_captured(command_line, {}, false)
    end

    # Run a program without capturing any output.  Returns the status object.
    def self.command(*command_line)
      raise ArgumentError, "command to run is empty" if command_line.empty?

      exec_read, exec_write = IO.pipe

      pid = Process.fork {
        exec_read.close
        exec_write.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC)
        begin
          Process.exec(*command_line)
        rescue
          exec_write.write($!.to_s)
        end
      }

      begin
        [exec_write].each {|io| io.close }

        error = exec_read.read
        if error.to_s != ''
          raise ForkExecError, "#{error}"
        end
      ensure
        exec_read.close if ! exec_read.closed?
      end

      Process.wait2(pid)[1]
    end

    # Run a program and return its [stdout, stderr, process].
    def self.run_captured(command_line, environment, print_output)
      raise ArgumentError, "command to run is empty" if command_line.empty?

      pipes = OpenStruct.new
      begin
        pipes.exec = IO.pipe
        pipes.stdout = IO.pipe
        pipes.stderr = IO.pipe
        ret = self.do_run_captured(command_line, environment, print_output, pipes)
      ensure
        read_end = 0
        [pipes.exec, pipes.stdout, pipes.stderr].each {|pipe|
          pipe.each {|io| io.close if ! io.closed? }
        }
      end
    end

    private

    def self.do_run_captured(command_line, environment, print_output, pipes)
      exec_read, exec_write = pipes.exec
      stdout_read, stdout_write = pipes.stdout
      stderr_read, stderr_write = pipes.stderr

      pid = Process.fork {
        environment.each_pair {|var,val| ENV[var] = val.to_s }

        [stdout_read, stderr_read, exec_read].each {|io| io.close }

        $stdout.reopen(stdout_write)
        $stderr.reopen(stderr_write)

        exec_write.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC)
        begin
          Process.exec(*command_line)
        rescue
          exec_write.write($!.to_s)
        end
      }

      [stdout_write, stderr_write, exec_write].each {|io| io.close }

      error = exec_read.read
      if error.to_s != ''
        raise ForkExecError, "#{error}"
      end

      stdout = ''
      stderr = ''

      read_some = lambda do |string,pipe|
        out = pipe.read(1024)
        string << out if out
        out
      end

      while true
        so = read_some.call(stdout, stdout_read)
        se = read_some.call(stderr, stderr_read)

        if print_output
          STDERR.write se if se
          STDOUT.write so if so
        end

        if se == nil && so == nil
          break
        end
      end

      status = Process.wait2(pid)[1]

      [stdout, stderr, status]
    end
  end

  # Functions which have identifiers trailed with exclamation marks can exit.
  class CommandLine
    def initialize(args); @args = args; end

    def run!
      @settings = Settings.new(@args).parse!

      puts "bmake: cd '#{@settings.test_dir}'" if @settings.verbose?
      in_directory(@settings.test_dir) {
        name_args = make_name_args
        check_tests_exist!(name_args) if name_args != []
        run_make!
        run_maybe_tests!
        run_tests!(name_args) if name_args != []
      }
    end

    private

    def tests_exist?(name_args)
      cl = %w{ctest -N} + name_args
      stdout, stderr, status = Fork.capture_command(*cl)

      if ! status.exited? || ! status.success?
        STDERR.puts "bmake: CMake failed when checking tests: output '#{stderr}'."
        Kernel.exit 1
      end

      # It doesn't print "No tests were found!!!" under -N mode.
      if stdout =~ /^[Tt]otal\s+[Tt]ests:\s*0\s*$/
        false
      else
        true
      end
    end

    def check_tests_exist!(name_args)
      if ! tests_exist?(name_args)
        STDERR.puts "bmake: no tests matching parameters given"
        Kernel.exit 1
      end

      nil
    end

    def run_make!
      return if ! @settings.make?

      prog = 'make'
      args = @settings.make_names
      args_str = args.empty? ? '' : "\"#{args.join('" "')}\""
      puts "bmake: exec: #{prog} #{args_str}"

      s = Fork.command(prog, *args)
      puts "bmake: #{prog} terminates with status #{s.exitstatus}"
      if ! s.success?
        Kernel.exit 1
      else
        s
      end
    end

    def run_maybe_tests!
      names = @settings.maybe_test_names
      return if names.empty?

      names.each {|name|
        args = ['-R', "^#{name}$"]
        if tests_exist?(args)
          run_tests!(args)
        elsif @settings.verbose?
          puts "bmake: target name '#{name}' is not a test"
        end
      }

      nil
    end

    def run_tests!(name_args)
      cl = %w{ctest --output-on-failure}
      cl << '-V' if @settings.verbose?
      cl += name_args

      puts "bmake: exec: #{cl[0]} \"#{cl[1..-1].join('" "')}\""
      status = Fork.command(*cl)
      if ! status.success?
        Kernel.exit 1
      elsif @settings.verbose?
        puts "bmake: test(s) matching #{name_args[1]} worked"
      end
    end

    def in_directory(d)
      old_d = Dir.pwd
      begin
        Dir.chdir(d)
        yield
      ensure
        Dir.chdir(old_d)
      end
    end

    # Return [-R, test_names] or [].
    def make_name_args
      re_arg = str_arg = nil

      if ! @settings.test_regexes.empty?
        re_arg = "(" + @settings.test_regexes.join(')|(') + ")"
      end

      if ! @settings.test_names.empty?
        str_arg = "^" + @settings.test_names.join('$|^') + "$"
      end

      if re_arg || str_arg
        ret = ['-R', [re_arg, str_arg].compact.join('|')]
      else
        ret = []
      end

      ret
    end
  end
end

CtestWrapper::CommandLine.new(ARGV).run!
