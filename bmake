#!/usr/bin/ruby
# Copyright (C) 2010, James Webber.
# Distributed under a 3-clause BSD license..  See COPYING.
#
# Wraps CMake's ctest with a more friendly UI and recognises my standard project
# structure.  See $0 --help

require 'optparse'
require 'pathname'
require 'fcntl'
require 'ostruct'

require '/home/bunker/src/rbunker/lib/rbunker/fork'

module BMake
  def Object.attr_bool_reader(*names)
    names.each {|name|
      module_eval "def #{name}?; @#{name}; end"
    }
  end

  # Finding relevant locations.  Used by settings.
  class PathFinder
    ROOT_SRC_DIR = Pathname.new('/home/bunker/src')
    ROOT_BIN_DIR = Pathname.new('/home/bunker/var/build')
    ROOT_WRITINGS_SRC_DIR = Pathname.new('/home/bunker/writings')
    ROOT_WRITINGS_BIN_DIR = ROOT_BIN_DIR + "./writings"

    # Which type of project?
    class ModeCode; end
    class ModeWritings; end

    attr_reader :mode
    attr_reader :bin_dir, :src_dir
    attr_reader :bin_subdir, :src_subdir

    def initialize(settings)
      @settings = settings
    end

    # Can exit.
    def find!
      @pwd_bits = split_path(Pathname.pwd.realpath)

      # This must be checked first because the writings bindir is a subdir of
      # the code project build dir.
      data = find_dir(ROOT_WRITINGS_SRC_DIR) || find_dir(ROOT_WRITINGS_BIN_DIR)
      if data
        writings_find(*data)
      else
        code_find
      end

      required = [
        @bin_dir, @src_dir, @bin_subdir, @src_subdir, @mode
      ]

      @pwd_bits = nil

      fail "missing variables: #{required.inspect}" if required.include?(nil)
    end

    private

    def writings_find(name, subdir_bits)
      @mode = ModeWritings
      @src_dir = ROOT_WRITINGS_SRC_DIR + name
      @bin_dir = ROOT_WRITINGS_BIN_DIR + name

      set_dirs(ROOT_WRITINGS_SRC_DIR, ROOT_WRITINGS_BIN_DIR, name)
      set_subdirs(subdir_bits)
    end

    def set_dirs(base_src, base_bin, name)
      @bin_dir = base_bin + name
      @src_dir = base_src + name

      if ! @src_dir.directory?
        STDERR.puts "bmake: this project does not appear to have a source directory: '#{@src_dir}'"
        Kernel.exit 1
      end

      if ! @bin_dir.directory?
        STDERR.puts "bmake: this project does not appear to have a binary directory: '#{@bin_dir}'"
        Kernel.exit 1
      end
    end

    # Separate due to the configuration directory bit needs be set before the
    # subdirs
    def set_subdirs(subdir_bits)
      @src_subdir = @src_dir + File.join(subdir_bits)
      @bin_subdir = @bin_dir + File.join(subdir_bits)
    end

    # Find directories if we're not in a writings directory (so find a code
    # project dir structure or exit).
    def code_find
      @mode = ModeCode
      data = find_dir(ROOT_SRC_DIR) || find_dir(ROOT_BIN_DIR)
      if ! data
        STDERR.puts "bmake: #{Dir.pwd}: does not appear to be a source or binary directory"
        Kernel.exit(1)
      end
      project_name, subdir_bits = data

      set_dirs(ROOT_SRC_DIR, ROOT_BIN_DIR, project_name)
      @bin_dir += "./#{@settings.configuration}"
      if ! @bin_dir.exist?
        STDERR.puts "bmake: configuration directory '#{@settings.configuration}' does not exist in bindir '#{@bin_dir.dirname}'"
        Kernel.exit 1
      end
      set_subdirs(subdir_bits)
    end

    def split_path(path)
      bits = []
      path.each_filename {|f| bits << f }
      bits
    end

    # Are we in the given dir?
    def in_dir?(array)
      @pwd_bits[0..(array.length-1)] == array
    end

    # Returns [project_name, subdir_array] for the project, or nothing if not in
    # the given prefix dir.
    def find_dir(dir)
      prefix_array = split_path(dir)
      if in_dir?(prefix_array)
        project_name = @pwd_bits[prefix_array.length]
        subdir = @pwd_bits[(prefix_array.length+1)..@pwd_bits.length]
        [project_name, subdir]
      else
        nil
      end
    end
  end

  # Add a delegate.
  module Delegate
    def self.add(variable, method, method_name = method)
      # TODO: how?
    end
  end

  class Settings
    # Which tests to run.
    attr_reader :test_names, :test_regexes
    # Tests to run if they are valid (iow it's not an error if they don't
    # exist).
    attr_reader :maybe_test_names
    # -V in ctest.
    attr_bool_reader :verbose
    # Whether to run cmake
    attr_bool_reader :cmake
    # Whether to run make.
    attr_bool_reader :make
    # Whether to run ctest.
    attr_bool_reader :test
    # [] for use nothing.
    attr_reader :make_names
    # Should we run program_cli
    attr_bool_reader :test_program
    # Command name and arguments for running the program.
    attr_reader :program_cli
    # Name of configuration (win32, unix etc.)
    attr_reader :configuration
    # Either :bindir, or :bin_subdir, depending on settings.
    attr_reader :working_dir

    # TODO:
    #   do these bits with the delegate thing

    # Base ~/var/bin ~/src dir (including configuration).
    def bin_dir; @paths.bin_dir; end
    def src_dir; @paths.src_dir; end
    # Directory under the main dirs, e.g. bin_dir + ./test/blah
    def bin_subdir; @paths.bin_subdir; end
    def src_subdir; @paths.src_subdir; end

    def initialize(args)
      @args = args
      @parser = make_parser
      @test = true
      @test_names = []
      @test_regexes = []
      @verbose = false
      @use_subdir = false
      @configuration = nil
      @make = true
      @make_names = []
      @maybe_test_names = []
      @test_program = false
      @program_cli = []
      @paths = nil
      @working_dir = nil
    end

    # Parses the arguments and maybe exits.
    def parse!
      other_args = []
      begin
        other_args = @parser.parse(@args)
      rescue OptionParser::ParseError => e
        STDERR.puts "bmake: #{e}"
        Kernel.exit 1
      end

      @configuration ||= 'unix'
      if ! @program_cli.empty?
        @program_cli += other_args
        @test_program = true
      elsif ! other_args.empty?
        @maybe_test_names = other_args
        @make_names += @maybe_test_names if @make
      end

      if ! @make
        if ! @make_names.empty?
          STDERR.puts "bmake: make has been disabled but make targets have been given"
          Kernel.exit 1
        elsif @test_names.empty? && @test_regexes.empty?
          STDERR.puts "bmake: make has been disabled and no test names have been given"
          Kernel.exit 1
        end
      end

      if ! @test
        if @test_program
          STDERR.puts "bmake: testing has been disabled but a test program is given"
          Kernel.exit 1
        elsif ! @test_names.empty?
          STDERR.puts "bmake: testing has been disabled but test names have been given"
          Kernel.exit 1
        elsif ! @test_regexes.empty?
          STDERR.puts "bmake: testing has been disabled but test regexes have been given"
          Kernel.exit 1
        end
      end

      if ! @make && ! @test && @maybe_test_names
        STDERR.puts "bmake: make and test are both disabled but there are test/target names given"
        Kernel.exit 1
      end

      @paths = PathFinder.new(self)
      @paths.find!
      @working_dir = @use_subdir ? @paths.bin_subdir : @paths.bin_dir

      if @paths.mode == PathFinder::ModeWritings
        unless @test_names.empty? && @test_regexes.empty?
          STDERR.puts "bmake: tests are not applicable for a writings project"
          Kernel.exit 1
        end

        if @make == false
          STDERR.puts "bmake: make must not be disabled for a writings project"
        end
      end

      self
    end

    private

    def make_parser
      op = OptionParser.new
      op.banner += " [targets]"
      op.banner += "\nBuilds and tests projects using the standard bunker project structure."
      op.banner += "\nTargets specified as non-options will be built with make and tested"
      op.banner += "\nonly if they are valid as test names.  If there are no targets and no"
      op.banner += "\nother arguments, then make all and all test will be run."
      op.banner += "\n\n"

      op.separator "General:"
      op.on('-h', '--help', "Print these options and exit.") {
        puts op
        puts
        puts "bmake Copyright (C) James Webber, 2010."
        Kernel.exit 0
      }
      op.on('-s', '--subdir', "Use a binary dir which mirrors the path in the srcdir when running tests.") {
        listfile = Pathname.getwd + "./CMakeLists.txt"
        if ! listfile.exist?
          STDERR.puts "bmake: --subdir cannot be used when there is no CMakeLists.txt in the pwd."
          Kernel.exit 1
        end
        @use_subdir = true
      }
      op.on('-c', '--config=CONFIG', "Configuration dir.  Default is 'unix'.") {|name|
        set_configuration(name)
      }
      op.on('-w', '--win', "Like --config=win.") {
        set_configuration('win')
      }
      op.on('-v', '--verbose', "Always print outputs of tests (and some other stuff).") { @verbose = true }

      op.separator "\nMaking:"
      op.on('-C', '--cmake', "Always run cmake first (helps if you updated the target names)") {
        @cmake = true
      }
      op.on('-M', '--no-make', "Don't call make.") {
        @make = false
      }
      op.on('-m', '--make=NAME', "Run this target when using make.  Can be given multiple times.") {|val|
        @make_names << val
      }

      op.separator "\nRunning:"
      msg = "Make a target and run its output binary.  " +
            "Other arguments are passed to this program (use '--' to cancel valid arguments to this program.)"
      op.on('-p', '--program=TARGET', msg) {|val|
        @make_names << val
        exit_fail("only one --program may be given") unless @program_cli.empty?
        @program_cli << val
      }

      op.separator "\nTesting:"
      op.on('-N', '--no-test', "Don't call ctest.") {
        @test = false
      }
      op.on('-t', '--test=NAME', "Name of test to run.  Can be given multiple times.") {|name|
        @test_names << name
      }
      op.on('-r', '--regex=EXPR', "A CMake regex to run tests matching.  Can be given multiple times.") {|val|
        @test_regexes << val
      }
      msg = "Same as giving -t NAME -m NAME.  This differs from non-argument " +
            "targets in that the test must exist."
      op.on('-T', '--test-target=NAME', msg) {|name|
        @test_names << name
        @make_names << name
      }

      op
    end

    # some comon valdiation
    def set_configuration(name)
      exit_fail("--config (or --win) may only be given once") if @configuration
      @configuration = name
    end

    def exit_fail(msg)
      STDERR.puts "bmake: #{msg}"
      Kernel.exit 1
    end
  end

  # Initialiser object for parameters of the testing.  Contains names of tests
  # where maybe means they're allowed to not exist.
  class TestConfig
    attr_accessor :names, :maybe_names
    attr_accessor :regexes
    attr_accessor :verbose

    def initialize
      @names = []
      @regexes = []
      @maybe_names = []
      @verbose = false
      @required_args = nil
    end
  end

  # Organises running tests and checking they exist.
  #
  # TODO:
  #   We should do the working directory stuff in here.
  class TestRunner
    # Modifications to config are ignored.
    def initialize(config)
      @config = config.dup
      @non_maybe_args = TestRunner.make_args(@config.names, @config.regexes)
    end

    # Check that required names are present.  This is done in advance to avoid
    # running a make first and then raising an error about the wrong target name.
    def check!
      if ! @non_maybe_args.empty? && ! tests_exist?(@non_maybe_args)
        STDERR.puts "bmake: no tests matching parameters given"
        Kernel.exit 1
      end
    end

    # Run everything given.
    def run!
      if ! any_named_tests?
        fail "shouldn't be called without any names"
      end

      if ! @non_maybe_args.empty?
        puts "bmake: running named tests" if @config.verbose
        run_tests!(@non_maybe_args)
      end

      maybe_args = TestRunner.make_args(@config.maybe_names, [])
      if ! maybe_args.empty?
        puts "bmake: running tests if they exist" if @config.verbose
        if tests_exist?(maybe_args)
          run_tests!(maybe_args)
        end
      end
    end

    # Run everthing there is.
    def run_all!
      puts "bmake: running all tests" if @config.verbose
      run_tests!(%w{-R .*})
    end

    # Are there any tests to run.
    def any_named_tests?
      ! @config.names.empty? || ! @config.maybe_names.empty? || ! @config.regexes.empty?
    end

    private

    def tests_exist?(name_args)
      cl = %w{ctest -N} + name_args
      stdout, stderr, status = Fork.capture_command(*cl)

      if ! status.exited? || ! status.success?
        STDERR.puts "bmake: CMake failed when checking tests: output '#{stderr}'."
        Kernel.exit 1
      end

      if @config.verbose
        STDOUT.write "bmake: check test exists with name args: #{name_args.join(' ')}... "
      end

      # It doesn't print "No tests were found!!!" under -N mode.
      if stdout =~ /^[Tt]otal\s+[Tt]ests:\s*0\s*$/
        puts "nope" if @config.verbose
        false
      else
        puts "yep" if @config.verbose
        true
      end
    end

    def run_tests!(name_args)
      cl = %w{ctest}
      cl << if @config.verbose then "-V" else "--output-on-failure" end
      cl += name_args

      puts "bmake: exec: #{cl[0]} \"#{cl[1..-1].join('" "')}\""
      status = Fork.command(*cl)
      if ! status.success?
        Kernel.exit 1
      elsif @config.verbose
        puts "bmake: test(s) matching #{name_args[1]} worked"
      end
    end

    # Return [-R, names and regexes] or [].
    def self.make_args(names, regexes)
      re_arg = str_arg = nil

      if ! regexes.empty?
        re_arg = "(" + regexes.join(')|(') + ")"
      end

      if ! names.empty?
        str_arg = "^" + names.join('$|^') + "$"
      end

      if re_arg || str_arg
        ret = ['-R', [re_arg, str_arg].compact.join('|')]
      else
        ret = []
      end

      ret
    end

  end

  # Functions which have identifiers trailed with exclamation marks can exit.
  class CommandLine
    def initialize(args); @args = args; end

    def run!
      @settings = Settings.new(@args).parse!

      tc = TestConfig.new
      tc.verbose = @settings.verbose?
      tc.names += @settings.test_names
      tc.regexes += @settings.test_regexes
      tc.maybe_names += @settings.maybe_test_names

      @tests = TestRunner.new(tc)

      puts "bmake: cd '#{@settings.working_dir}'" if @settings.verbose?
      in_directory(@settings.working_dir) {
        if @settings.cmake?
          run_cmake!
        end

        @tests.check!

        if @settings.make?
          run_make!
        elsif @settings.verbose?
          puts "bmake: running make is disabled"
        end

        if ! @settings.test?
          puts "bmake: running ctest is disabled" if @settings.verbose?
        elsif @settings.test_program?
          run_program!
        elsif @tests.any_named_tests?
          @tests.run!
        else
          @tests.run_all!
        end
      }
    end

    private

    def run_cmake!
      puts "bmake: running cmake" if @settings.verbose?
      if ! Fork.command("cmake", *%w{.}).success?
        Kernel.exit 1
      end
    end

    def run_make!
      prog = 'make'
      args = @settings.make_names
      args_str = args.empty? ? '' : "\"#{args.join('" "')}\""
      puts "bmake: exec: #{prog} #{args_str}"

      s = Fork.command(prog, *args)
      puts "bmake: #{prog} terminates with status #{s.exitstatus}"
      if ! s.success?
        Kernel.exit 1
      else
        s
      end
    end

    # Run Settings#program_cli.
    def run_program!
      args = []
      program = nil

      file = "./#{@settings.program_cli[0]}"
      if File.exist?(file)
        program = file
      elsif File.exist?(file + ".exe")
        puts "bmake: using wine emulator" if @settings.verbose?

        # This seems to be necessary.  Even if the .exe exists, ruby's exec()
        # won't load it despite having binfmt-support.
        program = "wine"
        args << file
      else
        STDERR.puts "bmake: program #{file} not found (try --subdir?)"
        Kernel.exit 1
      end

      args += @settings.program_cli[1..-1]

      if @settings.verbose?
        STDOUT.write "bmake: exec: #{program}"
        if ! args.empty?
          STDOUT.puts " \"#{args.join('", "')}\""
        else
          STDOUT.puts
        end
      end

      s = Fork.command(program, *args)
      if s.signaled?
        STDERR.puts "bmake: #{program} crashed with signal '#{s.termsig}'"
        Kernel.exit 1
      elsif ! s.success?
        STDERR.puts "bmake: #{program} failed with status '#{s.exitstatus}'"
        Kernel.exit 1
      end
    end

    def run_maybe_tests!
      puts "bmake: running target names if they are tests" if @settings.verbose?
      names = @settings.maybe_test_names
      return if names.empty?

      names.each {|name|
        args = ['-R', "^#{name}$"]
        if tests_exist?(args)
          run_tests!(args)
        elsif @settings.verbose?
          puts "bmake: target name '#{name}' is not a test: ignoring it"
        end
      }

      nil
    end

    def in_directory(d)
      old_d = Dir.pwd
      begin
        Dir.chdir(d)
        yield
      ensure
        Dir.chdir(old_d)
      end
    end
  end
end

BMake::CommandLine.new(ARGV).run!
