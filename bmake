#!/usr/bin/ruby
# Copyright (C) 2010, James Webber.
# Distributed under a 3-clause BSD license..  See COPYING.
#
# Wraps CMake's ctest with a more friendly UI and recognises my standard project
# structure.  See $0 --help

require 'optparse'
require 'pathname'
require 'fcntl'
require 'ostruct'

module BMake

  def Object.attr_bool_reader(*names)
    names.each {|name|
      module_eval "def #{name}?; @#{name}; end"
    }
  end

  # Finding relevant locations.  Used by settings.
  class PathFinder
    ROOT_SRC_DIR = Pathname.new('/home/bunker/src')
    ROOT_BIN_DIR = Pathname.new('/home/bunker/var/build')
    ROOT_WRITINGS_SRC_DIR = Pathname.new('/home/bunker/writings')
    ROOT_WRITINGS_BIN_DIR = ROOT_BIN_DIR + "./writings"

    # Which type of project?
    class ModeCode; end
    class ModeWritings; end

    attr_reader :mode
    attr_reader :bin_dir, :src_dir
    attr_reader :bin_subdir, :src_subdir

    def initialize(settings)
      @settings = settings
    end

    # Can exit.
    def find!
      @pwd_bits = split_path(Pathname.pwd.realpath)

      # This must be checked first because the writings bindir is a subdir of
      # the code project build dir.
      data = find_dir(ROOT_WRITINGS_SRC_DIR) || find_dir(ROOT_WRITINGS_BIN_DIR)
      if data
        writings_find(*data)
      else
        code_find
      end

      required = [
        @bin_dir, @src_dir, @bin_subdir, @src_subdir, @mode
      ]

      @pwd_bits = nil

      fail "missing variables: #{required.inspect}" if required.include?(nil)
    end

    private

    def writings_find(name, subdir_bits)
      @mode = ModeWritings
      @src_dir = ROOT_WRITINGS_SRC_DIR + name
      @bin_dir = ROOT_WRITINGS_BIN_DIR + name

      set_dirs(ROOT_WRITINGS_SRC_DIR, ROOT_WRITINGS_BIN_DIR, name, subdir_bits)
    end

    def set_dirs(base_src, base_bin, name, subdir_bits)
      @bin_dir = base_bin + name
      @src_dir = base_src + name

      @src_subdir = @src_dir + File.join(subdir_bits)
      @bin_subdir = @bin_dir + File.join(subdir_bits)

      if ! @src_dir.directory?
        STDERR.puts "bmake: this project does not appear to have a source directory: '#{@src_dir}'"
        Kernel.exit 1
      end

      if ! @bin_dir.directory?
        STDERR.puts "bmake: this project does not appear to have a binary directory: '#{@bin_dir}'"
        Kernel.exit 1
      end
    end

    # Find directories if we're not in a writings directory (so find a code
    # project dir structure or exit).
    def code_find
      @mode = ModeCode
      data = find_dir(ROOT_SRC_DIR) || find_dir(ROOT_BIN_DIR)
      if ! data
        STDERR.puts "bmake: #{Dir.pwd}: does not appear to be a source or binary directory"
        Kernel.exit(1)
      end
      project_name, subdir_bits = data

      set_dirs(ROOT_SRC_DIR, ROOT_BIN_DIR, project_name, subdir_bits)

      @bin_dir += "./#{@settings.configuration}"
      if ! @bin_dir.exist?
        STDERR.puts "bmake: configuration directory '#{@settings.configuration}' does not exist in bindir '#{@bin_dir.dirname}'"
        Kernel.exit 1
      end
    end

    def split_path(path)
      bits = []
      path.each_filename {|f| bits << f }
      bits
    end

    # Are we in the given dir?
    def in_dir?(array)
      @pwd_bits[0..(array.length-1)] == array
    end

    # Returns [project_name, subdir_array] for the project, or nothing if not in
    # the given prefix dir.
    def find_dir(dir)
      prefix_array = split_path(dir)
      if in_dir?(prefix_array)
        project_name = @pwd_bits[prefix_array.length]
        subdir = @pwd_bits[(prefix_array.length+1)..@pwd_bits.length]
        [project_name, subdir]
      else
        nil
      end
    end
  end

  # Add a delegate.
  module Delegate
    def self.add(variable, method, method_name = method)
      # TODO: how?
    end
  end

  class Settings
    # Which tests to run.
    attr_reader :test_names, :test_regexes
    # Tests to run if they are valid (iow it's not an error if they don't
    # exist).
    attr_reader :maybe_test_names
    # -V in ctest.
    attr_bool_reader :verbose
    # Whether to run make.
    attr_bool_reader :make
    # [] for use nothing.
    attr_reader :make_names
    # Whether to use the non-argument values on the cli as arguments to a
    # program.
    attr_bool_reader :run_program
    # Command name and arguments for running the program.
    attr_reader :program_cli
    # Name of configuration (win32, unix etc.)
    attr_reader :configuration
    # Either :bindir, or :bin_subdir, depending on settings.
    attr_reader :working_dir

    # TODO:
    #   do these bits with the delegate thing

    # Base ~/var/bin ~/src dir (including configuration).
    def bin_dir; @paths.bin_dir; end
    def src_dir; @paths.src_dir; end
    # Directory under the main dirs, e.g. bin_dir + ./test/blah
    def bin_subdir; @paths.bin_subdir; end
    def src_subdir; @paths.src_subdir; end

    def initialize(args)
      @args = args
      @parser = make_parser
      @test_names = []
      @test_regexes = []
      @verbose = false
      @use_subdir = false
      @configuration = nil
      @make = true
      @make_names = []
      @maybe_test_names = []
      @run_program = false
      @program_cli = []
      @paths = nil
      @working_dir = nil
    end

    # Parses the arguments and maybe exits.
    def parse!
      other_args = []
      begin
        other_args = @parser.parse(@args)
      rescue OptionParser::ParseError => e
        STDERR.puts "bmake: #{e}"
        Kernel.exit 1
      end

      @configuration ||= 'unix'
      if @run_program
        @program_cli += other_args
      else
        @maybe_test_names = other_args
        @make_names += @maybe_test_names
      end

      if @make == false
        if ! @make_names.empty?
          STDERR.puts "bmake: make has been disabled but make targets have been given"
          Kernel.exit 1
        elsif @test_names.empty? && @test_regexes.empty?
          STDERR.puts "bmake: make has been disabled and no test names have been given"
          Kernel.exit 1
        end
      elsif @test_names.empty? && @make_names.empty?
        @name_names = ['all']
      end

      @paths = PathFinder.new(self)
      @paths.find!
      @working_dir = @use_subdir ? @paths.bin_subdir : @paths.bin_dir

      if @paths.mode == PathFinder::ModeWritings
        unless @test_names.empty? && @test_regexes.empty?
          STDERR.puts "bmake: tests are not applicable for a writings project"
          Kernel.exit 1
        end

        if @make == false
          STDERR.puts "bmake: make must not be disabled for a writings project"
        end
      end

      self
    end

    private

    def make_parser
      op = OptionParser.new
      op.banner += " [targets]"
      op.banner += "\nBuilds and tests projects using the standard bunker project structure."
      op.banner += "\nTargets specified without arguments will be built with make and tested"
      op.banner += "\nonly if they are valid as test names.  If the --run argument is given"
      op.banner += "\nthen [targets] arguments are used as cli parameters."
      op.banner += "\n\n"

      op.separator "General:"
      op.on('-h', '--help', "Print these options and exit.") {
        puts op
        puts
        puts "bmake Copyright (C) James Webber, 2010."
        Kernel.exit 1
      }
      op.on('-s', '--subdir', "Use a binary dir which mirrors the path in the srcdir when running tests.") {
        listfile = Pathname.getwd + "./CMakeLists.txt"
        if ! listfile.exist?
          STDERR.puts "bmake: --subdir cannot be used when there is no CMakeLists.txt in the pwd."
          Kernel.exit 1
        end
        @use_subdir = true
      }
      op.on('-c', '--config=CONFIG', "Configuration dir.  Default is 'unix'.") {|name|
        set_configuration(name)
      }
      op.on('-w', '--win', "Like --config=win.") {
        set_configuration('win')
      }
      op.on('-v', '--verbose', "Always print outputs of tests (and some other stuff).") { @verbose = true }

      op.separator "\nMaking:"
      op.on('-M', '--no-make', "Don't call make.") {
        @make = false
      }
      op.on('-m', '--make=NAME', "Run this target when using make.  Can be given multiple times.") {|val|
        @make_names << val
      }

      op.separator "\nRunning:"
      op.on('-p', '--program=TARGET', "Make a target and run it.  Only be given once.") {|val|
        @make_names << val
        exit_fail("only one --program may be given") if @run_program
        @program_cli << val
        @run_program = true
      }

      op.separator "\nTesting:"
      op.on('-t', '--test=NAME', "Name of test to run.  Can be given multiple times.") {|name|
        @test_names << name
      }
      op.on('-r', '--regex=EXPR', "A CMake regex to run tests matching.  Can be given multiple times.") {|val|
        @test_regexes << val
      }
      op.on('-T', '--test-target=NAME', "Same as giving -t NAME -m NAME.") {|name|
        @test_names << name
        @make_names << name
      }

      op
    end

    # some comon valdiation
    def set_configuration(name)
      exit_fail("--config (or --win) may only be given once") if @configuration
      @configuration = name
    end

    def exit_fail(msg)
      STDERR.puts msg
      Kernel.exit 1
    end
  end

  class ForkExecError < RuntimeError
  end

  # Regarding making forks can running programs.
  module Fork
    # Fork a program.  Returns the [stdout, stderr, status] object.  Does not
    # print anything.
    def self.capture_command(*command_line)
      Fork.run_captured(command_line, {}, false)
    end

    # Run a program without capturing any output.  Returns the status object.
    def self.command(*command_line)
      raise ArgumentError, "command to run is empty" if command_line.empty?

      exec_read, exec_write = IO.pipe

      pid = Process.fork {
        exec_read.close
        exec_write.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC)

        begin
          Process.exec(*command_line)
        rescue
          exec_write.write($!.to_s)
        end
      }

      begin
        [exec_write].each {|io| io.close }

        error = exec_read.read
        if error.to_s != ''
          raise ForkExecError, "#{error}"
        end
      ensure
        exec_read.close if ! exec_read.closed?
      end

      Process.wait2(pid)[1]
    end

    # Run a program and return its [stdout, stderr, process].
    def self.run_captured(command_line, environment, print_output)
      raise ArgumentError, "command to run is empty" if command_line.empty?

      pipes = OpenStruct.new
      begin
        pipes.exec = IO.pipe
        pipes.stdout = IO.pipe
        pipes.stderr = IO.pipe
        ret = self.do_run_captured(command_line, environment, print_output, pipes)
      ensure
        read_end = 0
        [pipes.exec, pipes.stdout, pipes.stderr].each {|pipe|
          pipe.each {|io| io.close if ! io.closed? }
        }
      end
    end

    private

    def self.do_run_captured(command_line, environment, print_output, pipes)
      exec_read, exec_write = pipes.exec
      stdout_read, stdout_write = pipes.stdout
      stderr_read, stderr_write = pipes.stderr

      pid = Process.fork {
        environment.each_pair {|var,val| ENV[var] = val.to_s }

        [stdout_read, stderr_read, exec_read].each {|io| io.close }

        $stdout.reopen(stdout_write)
        $stderr.reopen(stderr_write)

        exec_write.fcntl(Fcntl::F_SETFD, Fcntl::FD_CLOEXEC)
        begin
          Process.exec(*command_line)
        rescue
          exec_write.write($!.to_s)
        end
      }

      [stdout_write, stderr_write, exec_write].each {|io| io.close }

      error = exec_read.read
      if error.to_s != ''
        raise ForkExecError, "#{error}"
      end

      stdout = ''
      stderr = ''

      read_some = lambda do |string,pipe|
        out = pipe.read(1024)
        string << out if out
        out
      end

      while true
        so = read_some.call(stdout, stdout_read)
        se = read_some.call(stderr, stderr_read)

        if print_output
          STDERR.write se if se
          STDOUT.write so if so
        end

        if se == nil && so == nil
          break
        end
      end

      status = Process.wait2(pid)[1]

      [stdout, stderr, status]
    end
  end

  # Functions which have identifiers trailed with exclamation marks can exit.
  class CommandLine
    def initialize(args); @args = args; end

    def run!
      @settings = Settings.new(@args).parse!

      puts "bmake: cd '#{@settings.working_dir}'" if @settings.verbose?
      in_directory(@settings.working_dir) {
        name_args = make_name_args
        check_tests_exist!(name_args) if name_args != []

        if @settings.make?
          run_make!
        elsif @settings.verbose?
          puts "bmake: running make is disabled"
        end

        if @settings.run_program?
          run_program!
        else
          run_maybe_tests!
          run_tests!(name_args) if name_args != []
        end
      }
    end

    private

    def tests_exist?(name_args)
      cl = %w{ctest -N} + name_args
      stdout, stderr, status = Fork.capture_command(*cl)

      if ! status.exited? || ! status.success?
        STDERR.puts "bmake: CMake failed when checking tests: output '#{stderr}'."
        Kernel.exit 1
      end

      if @settings.verbose?
        STDOUT.write "bmake: check test exists with name args: #{name_args.join(' ')}... "
      end

      # It doesn't print "No tests were found!!!" under -N mode.
      if stdout =~ /^[Tt]otal\s+[Tt]ests:\s*0\s*$/
        puts "nope" if @settings.verbose?
        false
      else
        puts "yep" if @settings.verbose?
        true
      end
    end

    def check_tests_exist!(name_args)
      if ! tests_exist?(name_args)
        STDERR.puts "bmake: no tests matching parameters given"
        Kernel.exit 1
      end

      nil
    end

    def run_make!
      prog = 'make'
      args = @settings.make_names
      args_str = args.empty? ? '' : "\"#{args.join('" "')}\""
      puts "bmake: exec: #{prog} #{args_str}"

      s = Fork.command(prog, *args)
      puts "bmake: #{prog} terminates with status #{s.exitstatus}"
      if ! s.success?
        Kernel.exit 1
      else
        s
      end
    end

    # Run Settings#program_cli.
    def run_program!
      args = []
      program = nil

      file = @settings.program_cli[0]
      if File.exist?(file)
        program = file
      elsif File.exist?(file + ".exe")
        puts "bmake: using wine emulator" if @settings.verbose?

        # This seems to be necessary.  Even if the .exe exists, ruby's exec()
        # won't load it despite having binfmt-support.
        program = "wine"
        args << file
      else
        STDERR.puts "bmake: program #{file} not found (try --subdir?)"
        Kernel.exit 1
      end

      args += @settings.program_cli[1..-1]

      if @settings.verbose?
        STDOUT.write "bmake: exec: #{program}"
        if ! args.empty?
          STDOUT.puts " \"#{args.join('", "')}\""
        else
          STDOUT.puts
        end
      end

      s = Fork.command(program, *args)
      if s.signaled?
        STDERR.puts "bmake: #{program} crashed with signal #{$?.signal}"
        Kernel.exit 1
      elsif ! s.success?
        STDERR.puts "bmake: #{program} failed with status #{$?.exitstatus}"
        Kernel.exit 1
      end
    end

    def run_maybe_tests!
      names = @settings.maybe_test_names
      return if names.empty?

      names.each {|name|
        args = ['-R', "^#{name}$"]
        if tests_exist?(args)
          run_tests!(args)
        elsif @settings.verbose?
          puts "bmake: target name '#{name}' is not a test"
        end
      }

      nil
    end

    def run_tests!(name_args)
      cl = %w{ctest}
      cl << if @settings.verbose? then "-V" else "--output-on-failure" end
      cl += name_args

      puts "bmake: exec: #{cl[0]} \"#{cl[1..-1].join('" "')}\""
      status = Fork.command(*cl)
      if ! status.success?
        Kernel.exit 1
      elsif @settings.verbose?
        puts "bmake: test(s) matching #{name_args[1]} worked"
      end
    end

    def in_directory(d)
      old_d = Dir.pwd
      begin
        Dir.chdir(d)
        yield
      ensure
        Dir.chdir(old_d)
      end
    end

    # Return [-R, test_names] or [].
    def make_name_args
      re_arg = str_arg = nil

      if ! @settings.test_regexes.empty?
        re_arg = "(" + @settings.test_regexes.join(')|(') + ")"
      end

      if ! @settings.test_names.empty?
        str_arg = "^" + @settings.test_names.join('$|^') + "$"
      end

      if re_arg || str_arg
        ret = ['-R', [re_arg, str_arg].compact.join('|')]
      else
        ret = []
      end

      ret
    end
  end
end

BMake::CommandLine.new(ARGV).run!
