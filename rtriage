#!/usr/bin/ruby -w
# Copyright (C) 2010, James Webber.  Distributed under a 3-clause BSD license;
# see COPYING.
#
# Parses relevant information from the spamdump of a ruby test including
# filtering not implemented tests and ignoring failures we already know about.
#
# See: $0 --help

# TODO:
#   New interface.
#
#   This is totally log-file based.  We check the tests coming from a log file
#   against a yaml state.
#
#   In the YAML file:
#
#   * state date
#   * list of known failing tests:
#     * date found
#     * status in [ignored, not implemented, broken, fixed]
#     * known: true | false
#     * keep: true | false # relevant if fixed
#     * reason/message
#     * comment from the user
#   * other data can be added later, such as command to run to get the test logs
#     etc.
#
#   The default interface of this program parses a given log file and checks it
#   against the yaml.  The script will output:
#
#   * new failures
#   * a change in the type of failure
#   * tests which are now correct (can be turned off)
#   * a change in the message (only if turned on)
#
#   If an --update-state option is given, the script will:
#
#   * add all failing tests which are not in the file
#   * update any existing tests, preserving the user's settings about them
#   * delete tests in the file which are now working unless the 'keep' setting
#     is given
#   * change the date of the state
#
#   This really needs tests, it must be said.
#
#   Therefore, the program interface must be
#
#   Usage: rtriage log-file
#   Statefully triages the errors in a ruby test log file.
#
#   State Options:
#     -s, --state=FILE  YAML state file.  If not given then rtriage.yaml in the
#                       present working directory is used.
#     --update-state    Modify the state with new information from the log file.
#
#   Display Options:
#     -C, --not-if-correct Don't output tests which have become correct.
#     --if-message         Display when the error message for a test has changed.
#     -k, --if-known       Display information about tests which haven't changed
#                          state.
#     -l, --long           Display long information of information.
#
#   Output should look like:
#
#   Changes since $old_data:
#
#   Unit::method -- $state (was $state) # use colors
#   Message (if long)
#   location / comamnd to run the test
#
#   Tests in the same state since $old_data: (if --all)
#
#   Unit::method -- $state
#   known about since $date
#   message (if --long)
#   location / comamnd to run the test
#
#   So tasks:
#
#   * modify settings to use the new argument scheme.
#   * the main() function will parse the file and buffer all error datas.
#   * make a decent implementation of ErrorPrinter for these output constraints
#   * make a class State (rename TestData) which handles reading and writing the
#     yaml state.  We can implement --update-state later.
#   * class ErrorData stores the data from the parser
#   * class Report which deals with displaying readable information from the
#     State and the ErrorData bits.
#   * we can optimise later to avoid lots of buffering and so on (e.g if we
#     aren't updating the state and we aren't displaying not implemented tests
#     when we can ignore not implemented bits)
#

require 'pathname'
require 'optparse'

base = (Pathname.new(__FILE__).realpath.dirname + "./rtriage-lib")
require base + "./utility.rb"
require base + "./statefullogparser.rb"
require base + "./logfileparser.rb"
require base + "./settings.rb"

module Triage
  # Handle the state of printing out errors.
  class ErrorPrinter
    def initialize(settings)
      @last_class = nil
    end

    # +parser+ is needed for the meta-info (e.g. suite name).
    def print(parser, error_data)
      e = error_data
      # we'll need settings regarding this
      failure = LogFileParser::TypeFailure
      error = LogFileParser::TypeError
      if e.type == error && e.message == 'not implemented'
        return
      elsif e.message =~ /not implemented/
        return
      end

      if @last_class != e.test_class
        @last_class = e.test_class
        puts "* #{e.test_class}"
      end

      puts "  - #{e.test_name}"
      puts "    #{e.message.match(/^[^\n]+/)}"
    end

    # Handle the unit counts.
    def totals(t)
    end
  end

  # Interface to the persistant state file.
  class State
    def initialize(settings, file)
      @settings = settings
      load_file(file)
    end

    # Update the state given the new data.
    def update_file(test_data)
      fail "not implemented"
    end

    private

    def load_file(name)
    end
  end

  # Queryable interface to the data extracted from the log file.
  class TestData
    # Fully initialise a new TestData from an io using the log parser.
    def self.from_file(name)
      lp = StatefulLogParser.new
      td = TestData.new
      File.open(name.to_s, 'r') {|io|
        io.each_line {|l|
          lp.line(l) {|data|
            td.add(data)
          }
        }
      }
      lp.finish
      t = lp.totals

      td
    end

    # Add data coming from the StatefulLogParser
    def add(data)
    end
  end

  # Output manager, using the TestData and State information to produce a full
  # report.
  class Report
    def initialize(settings, state, test_data)
      @settings = settings
      @state = state
      @test_data = test_data
    end

    def display
      p = ErrorPrinter.new(@settings)
    end
  end

  # Entry point for the program's command-line.
  class CommandLine
    def initialize(args)
      @args = args
      @settings = nil
    end

    def run!
      @settings = Settings.new.parse!(@args)
      state = State.new(@settings, @settings.state_file)
      test_data = TestData.from_file(@settings.log_file)
      report = Report.new(@settings, state, test_data)
      report.display
    end
  end
end

Triage::CommandLine.new(ARGV).run!
